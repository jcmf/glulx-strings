// Generated by CoffeeScript 1.9.0
(function() {
  var bytes, file, fs, _i, _len, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports.is_glulx = function(bytes) {
    return bytes.length > 36 && bytes[0] === 71 && bytes[1] === 108 && bytes[2] === 117 && bytes[3] === 108 && bytes[4] === 0;
  };

  exports.extract_glulx_strings = function(bytes, cb) {
    var assert, code_addr, code_end, code_start, data_addr, data_end, data_start, decode_huffman, decode_u32, decode_u8, header_size, huffman_root, ram_start, string_table_end, string_table_size, string_table_start, u32, u8, wrapped_cb, _i, _ref, _ref1;
    if (!exports.is_glulx(bytes)) {
      return;
    }
    u8 = function(addr) {
      return bytes[addr];
    };
    u32 = function(addr) {
      return u8(addr) * 0x1000000 + u8(addr + 1) * 0x10000 + u8(addr + 2) * 0x100 + u8(addr + 3);
    };
    ram_start = u32(8);
    string_table_start = u32(28);
    string_table_size = u32(string_table_start);
    string_table_end = string_table_start + string_table_size;
    huffman_root = u32(string_table_start + 8);
    header_size = 36;
    code_start = header_size;
    code_end = string_table_start;
    data_start = string_table_end;
    data_end = ram_start;
    decode_u8 = function(addr, cb) {
      var byte, chars;
      chars = [];
      while (true) {
        if (addr > data_end) {
          return;
        }
        byte = u8(addr);
        if (byte === 0) {
          return cb(chars.join(''));
        }
        chars.push(String.fromCharCode(byte));
        addr += 1;
      }
    };
    decode_u32 = function(addr, cb) {
      var chars, code_point;
      chars = [];
      while (true) {
        if (addr > data_end) {
          return;
        }
        code_point = u32(addr);
        if (code_point === 0) {
          return cb(chars.join(''));
        }
        chars.push(String.fromCharCode(code_point));
        addr += 4;
      }
    };
    decode_huffman = function(addr, cb) {
      var bit, bit_offset, pieces, tree_node;
      pieces = [];
      tree_node = huffman_root;
      bit_offset = -1;
      while (true) {
        bit_offset += 1;
        if (bit_offset === 8) {
          bit_offset = 0;
          addr += 1;
        }
        bit = (u8(addr) >> bit_offset) & 1;
        assert(u8(tree_node) === 0);
        tree_node = u32(tree_node + 1 + 4 * bit);
        switch (u8(tree_node)) {
          case 0:
            continue;
          case 1:
            return cb(pieces.join(''));
          case 2:
            pieces.push(String.fromCharCode(u8(tree_node + 1)));
            break;
          case 3:
            decode_u8(tree_node + 1, s(function() {
              return pieces.push(s);
            }));
            break;
          case 4:
            pieces.push(String.fromCharCode(u32(tree_node + 1)));
            break;
          case 5:
            decode_u32(tree_node + 1, s(function() {
              return pieces.push(s);
            }));
            break;
          default:
            cb(pieces.join(''));
            pieces = [];
        }
        tree_node = huffman_root;
      }
    };
    assert = require('assert');
    for (code_addr = _i = code_start; code_start <= code_end ? _i < code_end : _i > code_end; code_addr = code_start <= code_end ? ++_i : --_i) {
      data_addr = u32(code_addr);
      if (!((data_start <= data_addr && data_addr < data_end))) {
        continue;
      }
      wrapped_cb = function(s) {
        if (s) {
          return cb(s, data_addr, code_addr);
        }
      };
      switch (u8(data_addr)) {
        case 0xe0:
          decode_u8(data_addr + 1, wrapped_cb);
          break;
        case 0xe1:
          decode_huffman(data_addr + 1, wrapped_cb);
          break;
        case 0xe2:
          if (((0 === (_ref1 = u8(data_addr + 1)) && _ref1 === (_ref = u8(data_addr + 2))) && _ref === u8(data_addr + 3))) {
            decode_u32(data_addr + 4, wrapped_cb);
          }
      }
    }
  };

  exports.is_zcode = function(bytes) {
    var _ref;
    return bytes.length >= 0x40 && bytes[0] >= 3 && (bytes[0x10] & 0xfe) === 0 && ((bytes[0x12] & 0xf0) === (_ref = bytes[0x13] & 0xf0) && _ref === 0x30);
  };

  exports.extract_zcode_strings = function(bytes, cb) {
    var a0, a1, a2, abbrev_addr, code_addr, data_addr, decode_string, objname_addr, s, u16, unicode_table, unpack_addr, version, _i, _ref;
    if (!exports.is_zcode(bytes)) {
      return;
    }
    u16 = function(addr) {
      return bytes[addr] << 8 | bytes[addr + 1];
    };
    version = bytes[0];
    abbrev_addr = u16(0x18);
    unpack_addr = (function() {
      switch (version) {
        case 1:
        case 2:
        case 3:
          return function(packed_addr) {
            return 2 * packed_addr;
          };
        case 4:
        case 5:
          return function(packed_addr) {
            return 4 * packed_addr;
          };
        case 6:
        case 7:
          return (function() {
            var S_O;
            S_O = 8 * u16(0x2a);
            return function(packed_addr) {
              return 4 * packed_addr + S_O;
            };
          })();
        case 8:
          return function(packed_addr) {
            return 8 * packed_addr;
          };
        default:
          return function() {
            return bytes.length;
          };
      }
    })();
    objname_addr = (function() {
      var offset, stride, _ref;
      _ref = version < 4 ? [2 * 31, 9] : [2 * 63, 14], offset = _ref[0], stride = _ref[1];
      offset += stride - 2 + u16(0x0a);
      return function(obj_num) {
        return u16(obj_num * stride + offset);
      };
    })();
    a0 = 'abcdefghijklmnopqrstuvwxyz';
    a1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    a2 = 'x\n0123456789.,!?_#\'"/\\-:()';
    unicode_table = [0x0e4, 0x0f6, 0x0fc, 0x0c4, 0x0d6, 0x0dc, 0x0df, 0x0bb, 0x0ab, 0x0eb, 0x0ef, 0x0ff, 0x0cb, 0x0cf, 0x0e1, 0x0e9, 0x0ed, 0x0f3, 0x0fa, 0x0fd, 0x0c1, 0x0c9, 0x0cd, 0x0d3, 0x0da, 0x0dd, 0x0e0, 0x0e8, 0x0ec, 0x0f2, 0x0f9, 0x0c0, 0x0c8, 0x0cc, 0x0d2, 0x0d9, 0x0e2, 0x0ea, 0x0ee, 0x0f4, 0x0fb, 0x0c2, 0x0ca, 0x0ce, 0x0d4, 0x0db, 0x0e5, 0x0c5, 0x0f8, 0x0d8, 0x0e3, 0x0f1, 0x0f5, 0x0c3, 0x0d1, 0x0d5, 0x0e6, 0x0c6, 0x0e7, 0x0c7, 0x0fe, 0x0f0, 0x0de, 0x0d0, 0x0a3, 0x153, 0x152, 0x0a1, 0x0bf];
    decode_string = function(addr, no_abbrev) {
      var a, abbrev, piece, pieces, shift, tenbit, v, z, zscii, _i, _len, _ref;
      a = a0;
      abbrev = tenbit = null;
      pieces = [];
      while (true) {
        if (addr + 1 >= bytes.length) {
          return;
        }
        v = u16(addr);
        addr += 2;
        _ref = [10, 5, 0];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          shift = _ref[_i];
          z = (v >> shift) & 0x1f;
          if (abbrev) {
            a = u16(abbrev_addr + 2 * (32 * (abbrev - 1) + z));
            piece = decode_string(a, true);
            abbrev = null;
            if (!piece) {
              return;
            }
            pieces.push(piece);
          } else if (tenbit) {
            tenbit.push(z);
            if (tenbit.length < 2) {
              continue;
            }
            zscii = tenbit[0] << 5 | tenbit[1];
            tenbit = null;
            if (zscii >= 252) {
              return;
            } else if ((155 <= zscii && zscii < 155 + unicode_table.length)) {
              pieces.push(String.fromCharCode(unicode_table[zscii - 155]));
            } else {
              pieces.push((function() {
                switch (zscii) {
                  case 11:
                    return '  ';
                  case 13:
                    return '\n';
                  default:
                    return String.fromCharCode(zscii);
                }
              })());
            }
          } else if (z === 0) {
            pieces.push(' ');
            a = a0;
          } else if (__indexOf.call([1, 2, 3], z) >= 0) {
            if (no_abbrev) {
              return;
            }
            abbrev = z;
          } else if (z === 4) {
            a = a1;
          } else if (z === 5) {
            a = a2;
          } else if (z === 6 && a === a2) {
            tenbit = [];
            a = a0;
          } else {
            pieces.push(a[z - 6]);
            a = a0;
          }
        }
        if (v >> 15) {
          return pieces.join('');
        }
      }
    };
    for (code_addr = _i = 0, _ref = bytes.length; 0 <= _ref ? _i < _ref : _i > _ref; code_addr = 0 <= _ref ? ++_i : --_i) {
      data_addr = (function() {
        switch (bytes[code_addr]) {
          case 135:
            return u16(code_addr + 1);
          case 138:
            return objname_addr(u16(code_addr + 1));
          case 141:
            return unpack_addr(u16(code_addr + 1));
          case 178:
          case 179:
            return code_addr + 1;
        }
      })();
      if (data_addr && (s = decode_string(data_addr))) {
        cb(s, data_addr, code_addr);
      }
    }
  };

  exports.is_blorb = function(bytes) {
    var ch, i, magic, _i, _len;
    magic = 'FORM....IFRSRIdx';
    if (bytes.length < magic.length) {
      return false;
    }
    for (i = _i = 0, _len = magic.length; _i < _len; i = ++_i) {
      ch = magic[i];
      if (ch === '.') {
        continue;
      }
      if (bytes[i] !== ch.charCodeAt(0)) {
        return false;
      }
    }
    return true;
  };

  exports.unblorb = function(bytes, opts, cb) {
    var chunk_start, count, entry, i, id, number, offset, res_end, res_size, res_start, stride, type, u32, usage, _i, _ref;
    if (bytes.bytes || bytes.buffer) {
      _ref = [bytes.bytes || bytes.buffer, bytes, opts], bytes = _ref[0], opts = _ref[1], cb = _ref[2];
    }
    cb || (cb = opts.cb || opts.callback || opts);
    if (!bytes.slice) {
      bytes = new Buffer(bytes);
    }
    if (!exports.is_blorb(opts.bytes)) {
      return;
    }
    u32 = function(addr) {
      return bytes[addr] * 0x1000000 + bytes[addr + 1] * 0x10000 + bytes[addr + 2] * 0x100 + bytes[addr + 3];
    };
    id = function(addr) {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i <= 3; i = ++_i) {
          _results.push(String.fromCharCode(bytes[addr + i]));
        }
        return _results;
      })()).join('');
    };
    offset = 24;
    stride = 12;
    count = Math.min(u32(20), Math.floor(Math.min(u32(16) - 4, bytes.length - offset) / stride));
    for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
      entry = offset + stride * i;
      usage = id(entry);
      number = u32(entry + 4);
      chunk_start = u32(entry + 8);
      if (!chunk_start) {
        continue;
      }
      res_start = chunk_start + 8;
      if (res_start > bytes.length) {
        continue;
      }
      type = id(chunk_start);
      res_size = u32(chunk_start + 4);
      res_end = res_start + res_size;
      if (res_end > bytes.length) {
        continue;
      }
      if (opts.usage && opts.usage !== usage) {
        continue;
      }
      if ((opts.number != null) && opts.number !== number) {
        continue;
      }
      if (opts.type && opts.type !== type) {
        continue;
      }
      if (opts.type && opts.type !== type) {
        continue;
      }
      cb({
        usage: usage,
        number: number,
        type: type,
        bytes: bytes.slice(res_start, res_end)
      });
    }
  };

  exports.is_t3 = function(bytes) {
    var ch, i, magic, _i, _len;
    magic = 'T3-image\x0d\x0a\x1a';
    if (bytes.length < magic.length) {
      return false;
    }
    for (i = _i = 0, _len = magic.length; _i < _len; i = ++_i) {
      ch = magic[i];
      if (bytes[i] !== ch.charCodeAt(0)) {
        return false;
      }
    }
    return true;
  };

  exports.extract_t3_strings = function(bytes, cb) {
    var b, block_size, block_start, data_end, data_start, i, j, partial, pool_id, s, xor_mask, _i, _j, _ref;
    if (!exports.is_t3(bytes)) {
      return;
    }
    for (i = _i = 0, _ref = bytes.length - 17; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (bytes[i + 0] !== 67) {
        continue;
      }
      if (bytes[i + 1] !== 80) {
        continue;
      }
      if (bytes[i + 2] !== 80) {
        continue;
      }
      if (bytes[i + 3] !== 71) {
        continue;
      }
      block_start = i + 10;
      block_size = bytes[i + 4] + 0x100 * bytes[i + 5] + 0x10000 * bytes[i + 6] + 0x1000000 * bytes[i + 7];
      if (block_size <= 7) {
        continue;
      }
      if (block_start + block_size > bytes.length) {
        continue;
      }
      pool_id = bytes[block_start] | bytes[block_start + 1] << 8;
      if (pool_id !== 2) {
        continue;
      }
      xor_mask = bytes[block_start + 6];
      data_start = block_start + 7;
      data_end = block_start + block_size;
      partial = [];
      for (j = _j = data_start; data_start <= data_end ? _j < data_end : _j > data_end; j = data_start <= data_end ? ++_j : --_j) {
        b = bytes[j] ^ xor_mask;
        if (b >= 32) {
          partial.push(b);
          continue;
        }
        if (!partial.length) {
          continue;
        }
        s = (function() {
          try {
            return new Buffer(partial).toString();
          } catch (_error) {}
        })();
        partial = [];
        if (!s) {
          continue;
        }
        s = s.replace(/^\ufffd+/, '');
        s = s.replace(/\ufffd+$/, '');
        if (!s) {
          continue;
        }
        if (s.length < 4 && __indexOf.call(s, '\ufffd') >= 0) {
          continue;
        }
        cb(s, j - partial.length);
      }
    }
  };

  exports.extract_strings = function(bytes, cb) {
    exports.extract_glulx_strings(bytes, cb);
    exports.extract_zcode_strings(bytes, cb);
    exports.extract_t3_strings(bytes, cb);
    exports.unblorb({
      bytes: bytes,
      usage: 'Exec'
    }, function(resource) {
      return exports.extract_strings(resource.bytes, cb);
    });
    if (require('is-zip')(bytes)) {
      return require('zip').Reader(bytes).forEach(function(entry) {
        return exports.extract_strings(entry.getData(), cb);
      });
    }
  };

  if (module === require.main) {
    fs = require('fs');
    _ref = process.argv.slice(2);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      bytes = fs.readFileSync(file);
      exports.extract_strings(bytes, function(s) {
        s = s.trimRight();
        if (s) {
          return console.log(s);
        }
      });
    }
  }

}).call(this);

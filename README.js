// Generated by CoffeeScript 1.9.3
(function() {
  var bytes, file, fs, k, len1, ref,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports.is_glulx = function(bytes) {
    return bytes.length > 36 && bytes[0] === 71 && bytes[1] === 108 && bytes[2] === 117 && bytes[3] === 108 && bytes[4] === 0;
  };

  exports.extract_glulx_strings = function(bytes, cb) {
    var assert, code_addr, code_end, code_start, data_addr, data_end, data_start, decode_huffman, decode_u32, decode_u8, header_size, huffman_root, k, ram_start, ref, ref1, ref2, ref3, string_table_end, string_table_size, string_table_start, u32, u8, wrapped_cb;
    if (!exports.is_glulx(bytes)) {
      return;
    }
    u8 = function(addr) {
      return bytes[addr];
    };
    u32 = function(addr) {
      return u8(addr) * 0x1000000 + u8(addr + 1) * 0x10000 + u8(addr + 2) * 0x100 + u8(addr + 3);
    };
    ram_start = u32(8);
    string_table_start = u32(28);
    string_table_size = u32(string_table_start);
    string_table_end = string_table_start + string_table_size;
    huffman_root = u32(string_table_start + 8);
    header_size = 36;
    code_start = header_size;
    code_end = string_table_start;
    data_start = string_table_end;
    data_end = ram_start;
    decode_u8 = function(addr, cb) {
      var byte, chars;
      chars = [];
      while (true) {
        if (addr > data_end) {
          return;
        }
        byte = u8(addr);
        if (byte === 0) {
          return cb(chars.join(''));
        }
        chars.push(String.fromCharCode(byte));
        addr += 1;
      }
    };
    decode_u32 = function(addr, cb) {
      var chars, code_point;
      chars = [];
      while (true) {
        if (addr > data_end) {
          return;
        }
        code_point = u32(addr);
        if (code_point === 0) {
          return cb(chars.join(''));
        }
        chars.push(String.fromCharCode(code_point));
        addr += 4;
      }
    };
    decode_huffman = function(addr, cb) {
      var bit, bit_offset, pieces, tree_node;
      pieces = [];
      tree_node = huffman_root;
      bit_offset = -1;
      while (true) {
        bit_offset += 1;
        if (bit_offset === 8) {
          bit_offset = 0;
          addr += 1;
        }
        bit = (u8(addr) >> bit_offset) & 1;
        assert(u8(tree_node) === 0);
        tree_node = u32(tree_node + 1 + 4 * bit);
        switch (u8(tree_node)) {
          case 0:
            continue;
          case 1:
            return cb(pieces.join(''));
          case 2:
            pieces.push(String.fromCharCode(u8(tree_node + 1)));
            break;
          case 3:
            decode_u8(tree_node + 1, s(function() {
              return pieces.push(s);
            }));
            break;
          case 4:
            pieces.push(String.fromCharCode(u32(tree_node + 1)));
            break;
          case 5:
            decode_u32(tree_node + 1, s(function() {
              return pieces.push(s);
            }));
            break;
          default:
            cb(pieces.join(''));
            pieces = [];
        }
        tree_node = huffman_root;
      }
    };
    assert = require('assert');
    for (code_addr = k = ref = code_start, ref1 = code_end; ref <= ref1 ? k < ref1 : k > ref1; code_addr = ref <= ref1 ? ++k : --k) {
      data_addr = u32(code_addr);
      if (!((data_start <= data_addr && data_addr < data_end))) {
        continue;
      }
      wrapped_cb = function(s) {
        if (s) {
          return cb(s, data_addr, code_addr);
        }
      };
      switch (u8(data_addr)) {
        case 0xe0:
          decode_u8(data_addr + 1, wrapped_cb);
          break;
        case 0xe1:
          decode_huffman(data_addr + 1, wrapped_cb);
          break;
        case 0xe2:
          if (((0 === (ref3 = u8(data_addr + 1)) && ref3 === (ref2 = u8(data_addr + 2))) && ref2 === u8(data_addr + 3))) {
            decode_u32(data_addr + 4, wrapped_cb);
          }
      }
    }
  };

  exports.is_zcode = function(bytes) {
    var ref;
    return bytes.length >= 0x40 && bytes[0] >= 3 && (bytes[0x10] & 0xfe) === 0 && ((bytes[0x12] & 0xf0) === (ref = bytes[0x13] & 0xf0) && ref === 0x30);
  };

  exports.extract_zcode_strings = function(bytes, cb) {
    var a0, a1, a2, abbrev_addr, code_addr, data_addr, decode_string, k, objname_addr, ref, s, u16, unicode_table, unpack_addr, version;
    if (!exports.is_zcode(bytes)) {
      return;
    }
    u16 = function(addr) {
      return bytes[addr] << 8 | bytes[addr + 1];
    };
    version = bytes[0];
    abbrev_addr = u16(0x18);
    unpack_addr = (function() {
      switch (version) {
        case 1:
        case 2:
        case 3:
          return function(packed_addr) {
            return 2 * packed_addr;
          };
        case 4:
        case 5:
          return function(packed_addr) {
            return 4 * packed_addr;
          };
        case 6:
        case 7:
          return (function() {
            var S_O;
            S_O = 8 * u16(0x2a);
            return function(packed_addr) {
              return 4 * packed_addr + S_O;
            };
          })();
        case 8:
          return function(packed_addr) {
            return 8 * packed_addr;
          };
        default:
          return function() {
            return bytes.length;
          };
      }
    })();
    objname_addr = (function() {
      var offset, ref, stride;
      ref = version < 4 ? [2 * 31, 9] : [2 * 63, 14], offset = ref[0], stride = ref[1];
      offset += stride - 2 + u16(0x0a);
      return function(obj_num) {
        return u16(obj_num * stride + offset);
      };
    })();
    a0 = 'abcdefghijklmnopqrstuvwxyz';
    a1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    a2 = 'x\n0123456789.,!?_#\'"/\\-:()';
    unicode_table = [0x0e4, 0x0f6, 0x0fc, 0x0c4, 0x0d6, 0x0dc, 0x0df, 0x0bb, 0x0ab, 0x0eb, 0x0ef, 0x0ff, 0x0cb, 0x0cf, 0x0e1, 0x0e9, 0x0ed, 0x0f3, 0x0fa, 0x0fd, 0x0c1, 0x0c9, 0x0cd, 0x0d3, 0x0da, 0x0dd, 0x0e0, 0x0e8, 0x0ec, 0x0f2, 0x0f9, 0x0c0, 0x0c8, 0x0cc, 0x0d2, 0x0d9, 0x0e2, 0x0ea, 0x0ee, 0x0f4, 0x0fb, 0x0c2, 0x0ca, 0x0ce, 0x0d4, 0x0db, 0x0e5, 0x0c5, 0x0f8, 0x0d8, 0x0e3, 0x0f1, 0x0f5, 0x0c3, 0x0d1, 0x0d5, 0x0e6, 0x0c6, 0x0e7, 0x0c7, 0x0fe, 0x0f0, 0x0de, 0x0d0, 0x0a3, 0x153, 0x152, 0x0a1, 0x0bf];
    decode_string = function(addr, no_abbrev) {
      var a, aa, abbrev, k, len1, piece, pieces, ref, shift, tenbit, v, z, zscii;
      a = a0;
      abbrev = tenbit = null;
      pieces = [];
      while (true) {
        if (addr + 1 >= bytes.length) {
          return;
        }
        v = u16(addr);
        addr += 2;
        ref = [10, 5, 0];
        for (k = 0, len1 = ref.length; k < len1; k++) {
          shift = ref[k];
          z = (v >> shift) & 0x1f;
          if (abbrev) {
            aa = 2 * u16(abbrev_addr + 2 * (32 * (abbrev - 1) + z));
            piece = decode_string(aa, true);
            abbrev = null;
            if (!piece) {
              return;
            }
            pieces.push(piece);
          } else if (tenbit) {
            tenbit.push(z);
            if (tenbit.length < 2) {
              continue;
            }
            zscii = tenbit[0] << 5 | tenbit[1];
            tenbit = null;
            if (zscii >= 252) {
              return;
            } else if ((155 <= zscii && zscii < 155 + unicode_table.length)) {
              pieces.push(String.fromCharCode(unicode_table[zscii - 155]));
            } else {
              pieces.push((function() {
                switch (zscii) {
                  case 11:
                    return '  ';
                  case 13:
                    return '\n';
                  default:
                    return String.fromCharCode(zscii);
                }
              })());
            }
          } else if (z === 0) {
            pieces.push(' ');
            a = a0;
          } else if (indexOf.call([1, 2, 3], z) >= 0) {
            if (no_abbrev) {
              return;
            }
            abbrev = z;
          } else if (z === 4) {
            a = a1;
          } else if (z === 5) {
            a = a2;
          } else if (z === 6 && a === a2) {
            tenbit = [];
            a = a0;
          } else {
            pieces.push(a[z - 6]);
            a = a0;
          }
        }
        if (v >> 15) {
          return pieces.join('');
        }
      }
    };
    for (code_addr = k = 0, ref = bytes.length; 0 <= ref ? k < ref : k > ref; code_addr = 0 <= ref ? ++k : --k) {
      data_addr = (function() {
        switch (bytes[code_addr]) {
          case 135:
            return u16(code_addr + 1);
          case 138:
            return objname_addr(u16(code_addr + 1));
          case 141:
            return unpack_addr(u16(code_addr + 1));
          case 178:
          case 179:
            return code_addr + 1;
        }
      })();
      if (data_addr && (s = decode_string(data_addr))) {
        cb(s, data_addr, code_addr);
      }
    }
  };

  exports.is_blorb = function(bytes) {
    var ch, i, k, len1, magic;
    magic = 'FORM....IFRSRIdx';
    if (bytes.length < magic.length) {
      return false;
    }
    for (i = k = 0, len1 = magic.length; k < len1; i = ++k) {
      ch = magic[i];
      if (ch === '.') {
        continue;
      }
      if (bytes[i] !== ch.charCodeAt(0)) {
        return false;
      }
    }
    return true;
  };

  exports.unblorb = function(bytes, opts, cb) {
    var chunk_start, count, entry, i, id, k, number, offset, ref, ref1, res_end, res_size, res_start, stride, type, u32, usage;
    if (bytes.bytes || bytes.buffer) {
      ref = [bytes.bytes || bytes.buffer, bytes, opts], bytes = ref[0], opts = ref[1], cb = ref[2];
    }
    cb || (cb = opts.cb || opts.callback || opts);
    if (!bytes.slice) {
      bytes = new Buffer(bytes);
    }
    if (!exports.is_blorb(opts.bytes)) {
      return;
    }
    u32 = function(addr) {
      return bytes[addr] * 0x1000000 + bytes[addr + 1] * 0x10000 + bytes[addr + 2] * 0x100 + bytes[addr + 3];
    };
    id = function(addr) {
      var i;
      return ((function() {
        var k, results;
        results = [];
        for (i = k = 0; k <= 3; i = ++k) {
          results.push(String.fromCharCode(bytes[addr + i]));
        }
        return results;
      })()).join('');
    };
    offset = 24;
    stride = 12;
    count = Math.min(u32(20), Math.floor(Math.min(u32(16) - 4, bytes.length - offset) / stride));
    for (i = k = 0, ref1 = count; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
      entry = offset + stride * i;
      usage = id(entry);
      number = u32(entry + 4);
      chunk_start = u32(entry + 8);
      if (!chunk_start) {
        continue;
      }
      res_start = chunk_start + 8;
      if (res_start > bytes.length) {
        continue;
      }
      type = id(chunk_start);
      res_size = u32(chunk_start + 4);
      res_end = res_start + res_size;
      if (res_end > bytes.length) {
        continue;
      }
      if (opts.usage && opts.usage !== usage) {
        continue;
      }
      if ((opts.number != null) && opts.number !== number) {
        continue;
      }
      if (opts.type && opts.type !== type) {
        continue;
      }
      cb({
        usage: usage,
        number: number,
        type: type,
        bytes: bytes.slice(res_start, res_end)
      });
    }
  };

  exports.is_t3 = function(bytes) {
    var ch, i, k, len1, magic;
    magic = 'T3-image\x0d\x0a\x1a';
    if (bytes.length < magic.length) {
      return false;
    }
    for (i = k = 0, len1 = magic.length; k < len1; i = ++k) {
      ch = magic[i];
      if (bytes[i] !== ch.charCodeAt(0)) {
        return false;
      }
    }
    return true;
  };

  exports.extract_t3_strings = function(bytes, cb) {
    var b, block_size, block_start, data_addr, data_end, data_start, decoded, encoded, i, j, k, l, len1, m, pool_id, ref, ref1, ref2, ref3, s, xor_mask;
    if (!exports.is_t3(bytes)) {
      return;
    }
    for (i = k = 0, ref = bytes.length - 17; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      if (bytes[i + 0] !== 67) {
        continue;
      }
      if (bytes[i + 1] !== 80) {
        continue;
      }
      if (bytes[i + 2] !== 80) {
        continue;
      }
      if (bytes[i + 3] !== 71) {
        continue;
      }
      block_start = i + 10;
      block_size = bytes[i + 4] + 0x100 * bytes[i + 5] + 0x10000 * bytes[i + 6] + 0x1000000 * bytes[i + 7];
      if (block_size <= 7) {
        continue;
      }
      if (block_start + block_size > bytes.length) {
        continue;
      }
      pool_id = bytes[block_start] | bytes[block_start + 1] << 8;
      if (pool_id !== 2) {
        continue;
      }
      xor_mask = bytes[block_start + 6];
      data_start = block_start + 7;
      data_end = block_start + block_size;
      encoded = [];
      for (j = l = ref1 = data_start, ref2 = data_end; ref1 <= ref2 ? l < ref2 : l > ref2; j = ref1 <= ref2 ? ++l : --l) {
        b = bytes[j] ^ xor_mask;
        if (b >= 32) {
          encoded.push(b);
          continue;
        }
        if (!encoded.length) {
          continue;
        }
        data_addr = j - encoded.length;
        decoded = (function() {
          try {
            return new Buffer(encoded).toString();
          } catch (_error) {}
        })();
        encoded = [];
        if (!decoded) {
          continue;
        }
        ref3 = decoded.split('\ufffd');
        for (m = 0, len1 = ref3.length; m < len1; m++) {
          s = ref3[m];
          if (s) {
            cb(s, data_addr);
          }
        }
      }
    }
  };

  exports.is_tads2 = function(bytes) {
    var ch, i, k, len1, magic;
    magic = 'TADS2 bin\x0a\x0d\x1a\x00';
    if (bytes.length < magic.length) {
      return false;
    }
    for (i = k = 0, len1 = magic.length; k < len1; i = ++k) {
      ch = magic[i];
      if (bytes[i] !== ch.charCodeAt(0)) {
        return false;
      }
    }
    return true;
  };

  exports.extract_tads2_strings = function(bytes, cb) {
    var Stream, block, decrypt, id, name, next_pos, stream, type, xor_inc, xor_seed;
    if (!exports.is_tads2(bytes)) {
      return;
    }
    Stream = (function() {
      function Stream(buf1, base, pos1, end) {
        this.buf = buf1;
        this.base = base != null ? base : 0;
        this.pos = pos1 != null ? pos1 : 0;
        this.end = end != null ? end : this.buf.length;
      }

      Stream.prototype.len = function() {
        return this.end - this.pos;
      };

      Stream.prototype.eof = function() {
        return !this.len() > 0;
      };

      Stream.prototype.skip = function(len) {
        return this.pos += len;
      };

      Stream.prototype.seek = function(addr) {
        return this.pos = addr - this.base;
      };

      Stream.prototype.tell = function() {
        return this.base + this.pos;
      };

      Stream.prototype.u8 = function() {
        if (this.eof()) {
          throw new Error('eof');
        } else {
          return this.buf[this.pos++];
        }
      };

      Stream.prototype.u16 = function() {
        return this.u8() + 0x100 * this.u8();
      };

      Stream.prototype.u32 = function() {
        return this.u16() + 0x10000 * this.u16();
      };

      Stream.prototype.copy = function(len) {
        if (len == null) {
          len = this.len();
        }
        if (len > this.len()) {
          len = this.len;
        }
        return new Stream(this.buf, this.base, this.pos, this.pos += len);
      };

      Stream.prototype.bytes = function(len) {
        var i, k, ref, results;
        if (len == null) {
          len = this.len();
        }
        results = [];
        for (i = k = 0, ref = len; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
          if (!this.eof()) {
            results.push(this.u8());
          }
        }
        return results;
      };

      Stream.prototype.str = function(len) {
        var byte;
        return ((function() {
          var k, len1, ref, results;
          ref = this.bytes(len);
          results = [];
          for (k = 0, len1 = ref.length; k < len1; k++) {
            byte = ref[k];
            results.push(String.fromCharCode(byte));
          }
          return results;
        }).call(this)).join('');
      };

      Stream.prototype.extract = function(len) {
        var data_addr, s;
        data_addr = this.tell();
        s = this.str(len);
        if (s) {
          return cb(s, data_addr);
        }
      };

      Stream.prototype.skip_past = function(byte) {
        while (this.u8() !== byte) {
          if (this.eof()) {
            return;
          }
        }
      };

      Stream.prototype.extract_to = function(byte) {
        var len, start;
        start = this.pos;
        this.skip_past(byte);
        len = this.pos - 1 - start;
        this.pos = start;
        this.extract(len);
        return this.skip(1);
      };

      return Stream;

    })();
    stream = new Stream(bytes);
    stream.extract_to(0x0a);
    stream.skip_past(0);
    stream.extract_to(0);
    decrypt = stream.u16() & 8 === 0 ? function(buf) {
      return buf;
    } : (xor_seed = 63, xor_inc = 64, decrypt = function(bytes) {
      var byte, k, len1, results, xor_value;
      xor_value = xor_seed;
      results = [];
      for (k = 0, len1 = bytes.length; k < len1; k++) {
        byte = bytes[k];
        byte ^= xor_value;
        xor_value += xor_inc;
        xor_value &= 0xff;
        results.push(byte);
      }
      return results;
    });
    stream.extract_to(0);
    while (true) {
      name = stream.str(stream.u8());
      next_pos = stream.u32();
      block = stream.copy(next_pos - stream.tell());
      if (block.eof()) {
        return;
      }
      switch (name) {
        case '$EOF':
          return;
        case 'XSI':
          xor_seed = block.u8();
          xor_inc = block.u8();
          break;
        case 'OBJ':
          while (!block.eof()) {
            type = block.u8();
            id = block.u16();
            switch (type) {
              case 1:
              case 2:
                (function() {
                  var addr, b, bad, buf, byte, chars, data_end, data_len, data_start, k, len, len1, pos, results;
                  block.skip(2);
                  len = block.u16();
                  addr = block.tell();
                  buf = decrypt(block.bytes(len));
                  results = [];
                  for (pos = k = 0, len1 = buf.length; k < len1; pos = ++k) {
                    byte = buf[pos];
                    if (byte !== 3 && byte !== 9 && byte !== 29 && byte !== 31) {
                      continue;
                    }
                    data_start = pos + 3;
                    data_len = buf[pos + 1] + 0x100 * buf[pos + 2] - 2;
                    data_end = data_start + data_len;
                    if ((data_len >= 2 && data_end + 1 <= buf.length && buf[data_start + 1] === (data_len - 2) & 0xff, buf[data_start + 2] === (data_len - 2) >> 8)) {
                      data_start += 3;
                      data_end += 1;
                      data_len -= 2;
                    }
                    if (data_len < 0) {
                      continue;
                    }
                    if (data_end > buf.length) {
                      continue;
                    }
                    bad = false;
                    chars = (function() {
                      var l, len2, ref, results1;
                      ref = buf.slice(data_start, data_end);
                      results1 = [];
                      for (l = 0, len2 = ref.length; l < len2; l++) {
                        b = ref[l];
                        if (b <= 3) {
                          bad = true;
                        }
                        results1.push(String.fromCharCode(b));
                      }
                      return results1;
                    })();
                    if (bad) {
                      continue;
                    }
                    results.push(cb(chars.join(''), addr + data_start));
                  }
                  return results;
                })();
                break;
              case 10:
                block.skip(block.u8());
                break;
              default:
                block.skip(block.u16());
            }
          }
      }
      stream.seek(next_pos);
    }
  };

  exports.extract_strings = function(bytes, cb) {
    exports.extract_glulx_strings(bytes, cb);
    exports.extract_zcode_strings(bytes, cb);
    exports.extract_tads2_strings(bytes, cb);
    exports.extract_t3_strings(bytes, cb);
    exports.unblorb({
      bytes: bytes,
      usage: 'Exec'
    }, function(resource) {
      return exports.extract_strings(resource.bytes, cb);
    });
    if (require('is-zip')(bytes)) {
      return require('zip').Reader(bytes).forEach(function(entry) {
        return exports.extract_strings(entry.getData(), cb);
      });
    }
  };

  if (module === require.main) {
    fs = require('fs');
    ref = process.argv.slice(2);
    for (k = 0, len1 = ref.length; k < len1; k++) {
      file = ref[k];
      bytes = fs.readFileSync(file);
      exports.extract_strings(bytes, function(s) {
        s = s.trimRight();
        if (s) {
          return console.log(s);
        }
      });
    }
  }

}).call(this);

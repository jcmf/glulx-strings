// Generated by CoffeeScript 1.9.0
(function() {
  var bytes, file, fs, _i, _len, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports.is_glulx = function(bytes) {
    return bytes.length > 36 && bytes[0] === 71 && bytes[1] === 108 && bytes[2] === 117 && bytes[3] === 108 && bytes[4] === 0;
  };

  exports.extract_glulx_strings = function(bytes, cb) {
    var assert, code_addr, code_end, code_start, data_addr, data_end, data_start, decode_huffman, decode_u32, decode_u8, header_size, huffman_root, ram_start, string_table_end, string_table_size, string_table_start, u32, u8, wrapped_cb, _i, _ref, _ref1;
    if (!exports.is_glulx(bytes)) {
      return;
    }
    u8 = function(addr) {
      return bytes[addr];
    };
    u32 = function(addr) {
      return u8(addr) * 0x1000000 + u8(addr + 1) * 0x10000 + u8(addr + 2) * 0x100 + u8(addr + 3);
    };
    ram_start = u32(8);
    string_table_start = u32(28);
    string_table_size = u32(string_table_start);
    string_table_end = string_table_start + string_table_size;
    huffman_root = u32(string_table_start + 8);
    header_size = 36;
    code_start = header_size;
    code_end = string_table_start;
    data_start = string_table_end;
    data_end = ram_start;
    decode_u8 = function(addr, cb) {
      var byte, chars;
      chars = [];
      while (true) {
        if (addr > data_end) {
          return;
        }
        byte = u8(addr);
        if (byte === 0) {
          return cb(chars.join(''));
        }
        chars.push(String.fromCharCode(byte));
        addr += 1;
      }
    };
    decode_u32 = function(addr, cb) {
      var chars, code_point;
      chars = [];
      while (true) {
        if (addr > data_end) {
          return;
        }
        code_point = u32(addr);
        if (code_point === 0) {
          return cb(chars.join(''));
        }
        chars.push(String.fromCharCode(code_point));
        addr += 4;
      }
    };
    decode_huffman = function(addr, cb) {
      var bit, bit_offset, pieces, tree_node;
      pieces = [];
      tree_node = huffman_root;
      bit_offset = -1;
      while (true) {
        bit_offset += 1;
        if (bit_offset === 8) {
          bit_offset = 0;
          addr += 1;
        }
        bit = (u8(addr) >> bit_offset) & 1;
        assert(u8(tree_node) === 0);
        tree_node = u32(tree_node + 1 + 4 * bit);
        switch (u8(tree_node)) {
          case 0:
            continue;
          case 1:
            return cb(pieces.join(''));
          case 2:
            pieces.push(String.fromCharCode(u8(tree_node + 1)));
            break;
          case 3:
            decode_u8(tree_node + 1, s(function() {
              return pieces.push(s);
            }));
            break;
          case 4:
            pieces.push(String.fromCharCode(u32(tree_node + 1)));
            break;
          case 5:
            decode_u32(tree_node + 1, s(function() {
              return pieces.push(s);
            }));
            break;
          default:
            cb(pieces.join(''));
            pieces = [];
        }
        tree_node = huffman_root;
      }
    };
    assert = require('assert');
    for (code_addr = _i = code_start; code_start <= code_end ? _i < code_end : _i > code_end; code_addr = code_start <= code_end ? ++_i : --_i) {
      data_addr = u32(code_addr);
      if (!((data_start <= data_addr && data_addr < data_end))) {
        continue;
      }
      wrapped_cb = function(s) {
        if (s) {
          return cb(s, data_addr, code_addr);
        }
      };
      switch (u8(data_addr)) {
        case 0xe0:
          decode_u8(data_addr + 1, wrapped_cb);
          break;
        case 0xe1:
          decode_huffman(data_addr + 1, wrapped_cb);
          break;
        case 0xe2:
          if (((0 === (_ref1 = u8(data_addr + 1)) && _ref1 === (_ref = u8(data_addr + 2))) && _ref === u8(data_addr + 3))) {
            decode_u32(data_addr + 4, wrapped_cb);
          }
      }
    }
  };

  exports.is_zcode = function(bytes) {
    var _ref;
    return bytes.length >= 0x40 && bytes[0] >= 3 && (bytes[0x10] & 0xfe) === 0 && ((bytes[0x12] & 0xf0) === (_ref = bytes[0x13] & 0xf0) && _ref === 0x30);
  };

  exports.extract_zcode_strings = function(bytes, cb) {
    var a0, a1, a2, abbrev_addr, code_addr, data_addr, decode_string, objname_addr, s, u16, unicode_table, unpack_addr, version, _i, _ref;
    if (!exports.is_zcode(bytes)) {
      return;
    }
    u16 = function(addr) {
      return bytes[addr] << 8 | bytes[addr + 1];
    };
    version = bytes[0];
    abbrev_addr = u16(0x18);
    unpack_addr = (function() {
      switch (version) {
        case 1:
        case 2:
        case 3:
          return function(packed_addr) {
            return 2 * packed_addr;
          };
        case 4:
        case 5:
          return function(packed_addr) {
            return 4 * packed_addr;
          };
        case 6:
        case 7:
          return (function() {
            var S_O;
            S_O = 8 * u16(0x2a);
            return function(packed_addr) {
              return 4 * packed_addr + S_O;
            };
          })();
        case 8:
          return function(packed_addr) {
            return 8 * packed_addr;
          };
        default:
          return function() {
            return bytes.length;
          };
      }
    })();
    objname_addr = (function() {
      var offset, stride, _ref;
      _ref = version < 4 ? [2 * 31, 9] : [2 * 63, 14], offset = _ref[0], stride = _ref[1];
      offset += stride - 2 + u16(0x0a);
      return function(obj_num) {
        return u16(obj_num * stride + offset);
      };
    })();
    a0 = 'abcdefghijklmnopqrstuvwxyz';
    a1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    a2 = 'x\n0123456789.,!?_#\'"/\\-:()';
    unicode_table = [0x0e4, 0x0f6, 0x0fc, 0x0c4, 0x0d6, 0x0dc, 0x0df, 0x0bb, 0x0ab, 0x0eb, 0x0ef, 0x0ff, 0x0cb, 0x0cf, 0x0e1, 0x0e9, 0x0ed, 0x0f3, 0x0fa, 0x0fd, 0x0c1, 0x0c9, 0x0cd, 0x0d3, 0x0da, 0x0dd, 0x0e0, 0x0e8, 0x0ec, 0x0f2, 0x0f9, 0x0c0, 0x0c8, 0x0cc, 0x0d2, 0x0d9, 0x0e2, 0x0ea, 0x0ee, 0x0f4, 0x0fb, 0x0c2, 0x0ca, 0x0ce, 0x0d4, 0x0db, 0x0e5, 0x0c5, 0x0f8, 0x0d8, 0x0e3, 0x0f1, 0x0f5, 0x0c3, 0x0d1, 0x0d5, 0x0e6, 0x0c6, 0x0e7, 0x0c7, 0x0fe, 0x0f0, 0x0de, 0x0d0, 0x0a3, 0x153, 0x152, 0x0a1, 0x0bf];
    decode_string = function(addr, no_abbrev) {
      var a, abbrev, piece, pieces, shift, tenbit, v, z, zscii, _i, _len, _ref;
      a = a0;
      abbrev = tenbit = null;
      pieces = [];
      while (true) {
        if (addr + 1 >= bytes.length) {
          return;
        }
        v = u16(addr);
        addr += 2;
        _ref = [10, 5, 0];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          shift = _ref[_i];
          z = (v >> shift) & 0x1f;
          if (abbrev) {
            a = u16(abbrev_addr + 2 * (32 * (abbrev - 1) + z));
            piece = decode_string(a, true);
            abbrev = null;
            if (!piece) {
              return;
            }
            pieces.push(piece);
          } else if (tenbit) {
            tenbit.push(z);
            if (tenbit.length < 2) {
              continue;
            }
            zscii = tenbit[0] << 5 | tenbit[1];
            tenbit = null;
            if (zscii >= 252) {
              return;
            } else if ((155 <= zscii && zscii < 155 + unicode_table.length)) {
              pieces.push(String.fromCharCode(unicode_table[zscii - 155]));
            } else {
              pieces.push((function() {
                switch (zscii) {
                  case 11:
                    return '  ';
                  case 13:
                    return '\n';
                  default:
                    return String.fromCharCode(zscii);
                }
              })());
            }
          } else if (z === 0) {
            pieces.push(' ');
            a = a0;
          } else if (__indexOf.call([1, 2, 3], z) >= 0) {
            if (no_abbrev) {
              return;
            }
            abbrev = z;
          } else if (z === 4) {
            a = a1;
          } else if (z === 5) {
            a = a2;
          } else if (z === 6 && a === a2) {
            tenbit = [];
            a = a0;
          } else {
            pieces.push(a[z - 6]);
            a = a0;
          }
        }
        if (v >> 15) {
          return pieces.join('');
        }
      }
    };
    for (code_addr = _i = 0, _ref = bytes.length; 0 <= _ref ? _i < _ref : _i > _ref; code_addr = 0 <= _ref ? ++_i : --_i) {
      data_addr = (function() {
        switch (bytes[code_addr]) {
          case 135:
            return u16(code_addr + 1);
          case 138:
            return objname_addr(u16(code_addr + 1));
          case 141:
            return unpack_addr(u16(code_addr + 1));
          case 178:
          case 179:
            return code_addr + 1;
        }
      })();
      if (data_addr && (s = decode_string(data_addr))) {
        cb(s, data_addr, code_addr);
      }
    }
  };

  exports.is_blorb = function(bytes) {
    var ch, i, magic, _i, _len;
    magic = 'FORM....IFRSRIdx';
    if (bytes.length < magic.length) {
      return false;
    }
    for (i = _i = 0, _len = magic.length; _i < _len; i = ++_i) {
      ch = magic[i];
      if (ch === '.') {
        continue;
      }
      if (bytes[i] !== ch.charCodeAt(0)) {
        return false;
      }
    }
    return true;
  };

  exports.unblorb = function(bytes, opts, cb) {
    var chunk_start, count, entry, i, id, number, offset, res_end, res_size, res_start, stride, type, u32, usage, _i, _ref;
    if (bytes.bytes || bytes.buffer) {
      _ref = [bytes.bytes || bytes.buffer, bytes, opts], bytes = _ref[0], opts = _ref[1], cb = _ref[2];
    }
    cb || (cb = opts.cb || opts.callback || opts);
    if (!bytes.slice) {
      bytes = new Buffer(bytes);
    }
    if (!exports.is_blorb(opts.bytes)) {
      return;
    }
    u32 = function(addr) {
      return bytes[addr] * 0x1000000 + bytes[addr + 1] * 0x10000 + bytes[addr + 2] * 0x100 + bytes[addr + 3];
    };
    id = function(addr) {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i <= 3; i = ++_i) {
          _results.push(String.fromCharCode(bytes[addr + i]));
        }
        return _results;
      })()).join('');
    };
    offset = 24;
    stride = 12;
    count = Math.min(u32(20), Math.floor(Math.min(u32(16) - 4, bytes.length - offset) / stride));
    for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
      entry = offset + stride * i;
      usage = id(entry);
      number = u32(entry + 4);
      chunk_start = u32(entry + 8);
      if (!chunk_start) {
        continue;
      }
      res_start = chunk_start + 8;
      if (res_start > bytes.length) {
        continue;
      }
      type = id(chunk_start);
      res_size = u32(chunk_start + 4);
      res_end = res_start + res_size;
      if (res_end > bytes.length) {
        continue;
      }
      if (opts.usage && opts.usage !== usage) {
        continue;
      }
      if ((opts.number != null) && opts.number !== number) {
        continue;
      }
      if (opts.type && opts.type !== type) {
        continue;
      }
      cb({
        usage: usage,
        number: number,
        type: type,
        bytes: bytes.slice(res_start, res_end)
      });
    }
  };

  exports.is_t3 = function(bytes) {
    var ch, i, magic, _i, _len;
    magic = 'T3-image\x0d\x0a\x1a';
    if (bytes.length < magic.length) {
      return false;
    }
    for (i = _i = 0, _len = magic.length; _i < _len; i = ++_i) {
      ch = magic[i];
      if (bytes[i] !== ch.charCodeAt(0)) {
        return false;
      }
    }
    return true;
  };

  exports.extract_t3_strings = function(bytes, cb) {
    var b, block_size, block_start, data_addr, data_end, data_start, decoded, encoded, i, j, pool_id, s, xor_mask, _i, _j, _k, _len, _ref, _ref1;
    if (!exports.is_t3(bytes)) {
      return;
    }
    for (i = _i = 0, _ref = bytes.length - 17; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (bytes[i + 0] !== 67) {
        continue;
      }
      if (bytes[i + 1] !== 80) {
        continue;
      }
      if (bytes[i + 2] !== 80) {
        continue;
      }
      if (bytes[i + 3] !== 71) {
        continue;
      }
      block_start = i + 10;
      block_size = bytes[i + 4] + 0x100 * bytes[i + 5] + 0x10000 * bytes[i + 6] + 0x1000000 * bytes[i + 7];
      if (block_size <= 7) {
        continue;
      }
      if (block_start + block_size > bytes.length) {
        continue;
      }
      pool_id = bytes[block_start] | bytes[block_start + 1] << 8;
      if (pool_id !== 2) {
        continue;
      }
      xor_mask = bytes[block_start + 6];
      data_start = block_start + 7;
      data_end = block_start + block_size;
      encoded = [];
      for (j = _j = data_start; data_start <= data_end ? _j < data_end : _j > data_end; j = data_start <= data_end ? ++_j : --_j) {
        b = bytes[j] ^ xor_mask;
        if (b >= 32) {
          encoded.push(b);
          continue;
        }
        if (!encoded.length) {
          continue;
        }
        data_addr = j - encoded.length;
        decoded = (function() {
          try {
            return new Buffer(encoded).toString();
          } catch (_error) {}
        })();
        encoded = [];
        if (!decoded) {
          continue;
        }
        _ref1 = decoded.split('\ufffd');
        for (_k = 0, _len = _ref1.length; _k < _len; _k++) {
          s = _ref1[_k];
          if (s) {
            cb(s, data_addr);
          }
        }
      }
    }
  };

  exports.is_tads2 = function(bytes) {
    var ch, i, magic, _i, _len;
    magic = 'TADS2 bin\x0a\x0d\x1a\x00';
    if (bytes.length < magic.length) {
      return false;
    }
    for (i = _i = 0, _len = magic.length; _i < _len; i = ++_i) {
      ch = magic[i];
      if (bytes[i] !== ch.charCodeAt(0)) {
        return false;
      }
    }
    return true;
  };

  exports.extract_tads2_strings = function(bytes, cb) {
    var Stream, block, decrypt, id, name, next_pos, stream, type, xor_inc, xor_seed;
    if (!exports.is_tads2(bytes)) {
      return;
    }
    decrypt = function(buf) {
      return buf;
    };
    Stream = (function() {
      function Stream(_at_buf, _at_base, _at_pos, _at_end) {
        this.buf = _at_buf;
        this.base = _at_base != null ? _at_base : 0;
        this.pos = _at_pos != null ? _at_pos : 0;
        this.end = _at_end != null ? _at_end : this.buf.length;
      }

      Stream.prototype.len = function() {
        return this.end - this.pos;
      };

      Stream.prototype.eof = function() {
        return !this.len() > 0;
      };

      Stream.prototype.skip = function(len) {
        return this.pos += len;
      };

      Stream.prototype.seek = function(addr) {
        return this.pos = addr - this.base;
      };

      Stream.prototype.tell = function() {
        return this.base + this.pos;
      };

      Stream.prototype.u8 = function() {
        if (this.eof()) {
          throw new Error('eof');
        } else {
          return this.buf[this.pos++];
        }
      };

      Stream.prototype.u16 = function() {
        return this.u8() + 0x100 * this.u8();
      };

      Stream.prototype.u32 = function() {
        return this.u16() + 0x10000 * this.u16();
      };

      Stream.prototype.copy = function(len) {
        if (len == null) {
          len = this.len();
        }
        if (len > this.len()) {
          len = this.len;
        }
        return new Stream(this.buf, this.base, this.pos, this.pos += len);
      };

      Stream.prototype.bytes = function(len) {
        var i, _i, _results;
        if (len == null) {
          len = this.len();
        }
        _results = [];
        for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
          if (!this.eof()) {
            _results.push(this.u8());
          }
        }
        return _results;
      };

      Stream.prototype.decrypt = function(len) {
        var base, buf;
        base = this.tell();
        buf = decrypt(this.bytes(len));
        return new Stream(buf, base, 0, buf.length);
      };

      Stream.prototype.str = function(len) {
        var byte;
        return ((function() {
          var _i, _len, _ref, _results;
          _ref = this.bytes(len);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            byte = _ref[_i];
            _results.push(String.fromCharCode(byte));
          }
          return _results;
        }).call(this)).join('');
      };

      Stream.prototype.extract = function(len) {
        var data_addr, s;
        data_addr = this.tell();
        s = this.str(len);
        if (s) {
          return cb(s, data_addr);
        }
      };

      Stream.prototype.skip_past = function(byte) {
        while (this.u8() !== byte) {
          if (this.eof()) {
            return;
          }
        }
      };

      Stream.prototype.extract_to = function(byte) {
        var len, start;
        start = this.pos;
        this.skip_past(byte);
        len = this.pos - 1 - start;
        this.pos = start;
        this.extract(len);
        return this.skip(1);
      };

      return Stream;

    })();
    stream = new Stream(bytes);
    stream.extract_to(0x0a);
    stream.skip_past(0);
    stream.extract_to(0);
    if (stream.u16() & 8) {
      xor_seed = 63;
      xor_inc = 64;
      decrypt = function(bytes) {
        var byte, xor_value, _i, _len, _results;
        xor_value = xor_seed;
        _results = [];
        for (_i = 0, _len = bytes.length; _i < _len; _i++) {
          byte = bytes[_i];
          byte ^= xor_value;
          xor_value += xor_inc;
          xor_value &= 0xff;
          _results.push(byte);
        }
        return _results;
      };
    }
    stream.extract_to(0);
    while (true) {
      name = stream.str(stream.u8());
      next_pos = stream.u32();
      console.log("XXX name=" + name + " next_pos=" + next_pos + " stream.tell()=" + (stream.tell()));
      block = stream.copy(next_pos - stream.tell());
      console.log("XXX block.len()=" + (block.len()));
      if (block.eof()) {
        return;
      }
      switch (name) {
        case '$EOF':
          return;
        case 'XSI':
          xor_seed = block.u8();
          xor_inc = block.u8();
          break;
        case 'OBJ':
          while (!block.eof()) {
            type = block.u8();
            id = block.u16();
            switch (type) {
              case 1:
                (function() {
                  var addr, b, bad, byte, cache_len, chars, code, code_addr, data_addr, data_end, data_len, data_start, len, pos, s, _i, _len, _results;
                  len = block.u16();
                  cache_len = block.u16();
                  addr = block.tell();
                  code = block.decrypt(cache_len).bytes();
                  _results = [];
                  for (pos = _i = 0, _len = code.length; _i < _len; pos = ++_i) {
                    byte = code[pos];
                    if (byte === 29 || byte === 31) {
                      data_len = code[pos + 1] + 0x100 * code[pos + 2] - 2;
                      data_start = pos + 3;
                      data_end = data_start + data_len;
                      if (data_len > 0 && data_end <= code.length) {
                        code_addr = addr + pos;
                        data_addr = addr + data_start;
                        bad = false;
                        chars = (function() {
                          var _j, _len1, _ref, _results1;
                          _ref = code.slice(data_start, data_end);
                          _results1 = [];
                          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                            b = _ref[_j];
                            if (b === 0) {
                              bad = true;
                            }
                            _results1.push(String.fromCharCode(b));
                          }
                          return _results1;
                        })();
                        if (!bad) {
                          s = chars.join('');
                          _results.push(cb(s, data_addr, code_addr));
                        } else {
                          _results.push(void 0);
                        }
                      } else {
                        _results.push(void 0);
                      }
                    } else {
                      _results.push(void 0);
                    }
                  }
                  return _results;
                })();
                break;
              case 2:
                (function() {
                  var cache_len, len;
                  len = block.u16();
                  cache_len = block.u16();
                  console.log("XXX skipping type=" + type + " id=" + id + " len=" + len + " cache_len=" + len);
                  return block.skip(cache_len);
                })();
                break;
              default:
                console.log('XXX unknown object type=#{type} id=#{id}');
                break;
            }
          }
      }
      stream.seek(next_pos);
      console.log("XXX next_pos=" + next_pos + " stream.tell()=" + (stream.tell()) + " stream.pos=" + stream.pos + " stream.base=" + stream.base);
    }
  };

  exports.extract_strings = function(bytes, cb) {
    exports.extract_glulx_strings(bytes, cb);
    exports.extract_zcode_strings(bytes, cb);
    exports.extract_tads2_strings(bytes, cb);
    exports.extract_t3_strings(bytes, cb);
    exports.unblorb({
      bytes: bytes,
      usage: 'Exec'
    }, function(resource) {
      return exports.extract_strings(resource.bytes, cb);
    });
    if (require('is-zip')(bytes)) {
      return require('zip').Reader(bytes).forEach(function(entry) {
        return exports.extract_strings(entry.getData(), cb);
      });
    }
  };

  if (module === require.main) {
    fs = require('fs');
    _ref = process.argv.slice(2);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      bytes = fs.readFileSync(file);
      exports.extract_strings(bytes, function(s) {
        s = s.trimRight();
        if (s) {
          return console.log(s);
        }
      });
    }
  }

}).call(this);

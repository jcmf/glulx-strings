// Generated by CoffeeScript 1.9.0
(function() {
  var bytes, fs,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports.extract_glulx_strings = function(bytes, cb) {
    var assert, code_addr, code_end, code_start, data_addr, data_end, data_start, decode_huffman, decode_u32, decode_u8, fail, glulx_start, header_size, huffman_root, i, ram_start, string_table_end, string_table_size, string_table_start, u32, u8, wrapped_cb, _i, _j, _ref, _ref1, _ref2;
    fail = function(msg) {
      throw new Error(msg);
    };
    header_size = 36;
    if (bytes.length < header_size) {
      fail('file is too short to be glulx');
    }
    for (i = _i = 0, _ref = bytes.length - header_size; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (bytes[i] === 71 && bytes[i + 1] === 108 && bytes[i + 2] === 117 && bytes[i + 3] === 108 && bytes[i + 4] === 0) {
        glulx_start = i;
        break;
      }
    }
    if (glulx_start == null) {
      fail('not a glulx file');
    }
    u8 = function(addr) {
      return bytes[glulx_start + addr];
    };
    u32 = function(addr) {
      return u8(addr) * 0x1000000 + u8(addr + 1) * 0x10000 + u8(addr + 2) * 0x100 + u8(addr + 3);
    };
    ram_start = u32(8);
    string_table_start = u32(28);
    string_table_size = u32(string_table_start);
    string_table_end = string_table_start + string_table_size;
    huffman_root = u32(string_table_start + 8);
    code_start = header_size;
    code_end = string_table_start;
    data_start = string_table_end;
    data_end = ram_start;
    decode_u8 = function(addr, cb) {
      var byte, chars;
      chars = [];
      while (true) {
        if (addr > data_end) {
          return;
        }
        byte = u8(addr);
        if (byte === 0) {
          return cb(chars.join(''));
        }
        chars.push(String.fromCharCode(byte));
        addr += 1;
      }
    };
    decode_u32 = function(addr, cb) {
      var chars, code_point;
      chars = [];
      while (true) {
        if (addr > data_end) {
          return;
        }
        code_point = u32(addr);
        if (code_point === 0) {
          return cb(chars.join(''));
        }
        chars.push(String.fromCharCode(code_point));
        addr += 4;
      }
    };
    decode_huffman = function(addr, cb) {
      var bit, bit_offset, pieces, tree_node;
      pieces = [];
      tree_node = huffman_root;
      bit_offset = -1;
      while (true) {
        bit_offset += 1;
        if (bit_offset === 8) {
          bit_offset = 0;
          addr += 1;
        }
        bit = (u8(addr) >> bit_offset) & 1;
        assert(u8(tree_node) === 0);
        tree_node = u32(tree_node + 1 + 4 * bit);
        switch (u8(tree_node)) {
          case 0:
            continue;
          case 1:
            return cb(pieces.join(''));
          case 2:
            pieces.push(String.fromCharCode(u8(tree_node + 1)));
            break;
          case 3:
            decode_u8(tree_node + 1, s(function() {
              return pieces.push(s);
            }));
            break;
          case 4:
            pieces.push(String.fromCharCode(u32(tree_node + 1)));
            break;
          case 5:
            decode_u32(tree_node + 1, s(function() {
              return pieces.push(s);
            }));
            break;
          default:
            cb(pieces.join(''));
            pieces = [];
        }
        tree_node = huffman_root;
      }
    };
    assert = require('assert');
    for (code_addr = _j = code_start; code_start <= code_end ? _j < code_end : _j > code_end; code_addr = code_start <= code_end ? ++_j : --_j) {
      data_addr = u32(code_addr);
      if (!((data_start <= data_addr && data_addr < data_end))) {
        continue;
      }
      wrapped_cb = function(s) {
        if (s) {
          return cb(s, data_addr, code_addr);
        }
      };
      switch (u8(data_addr)) {
        case 0xe0:
          decode_u8(data_addr + 1, wrapped_cb);
          break;
        case 0xe1:
          decode_huffman(data_addr + 1, wrapped_cb);
          break;
        case 0xe2:
          if (((0 === (_ref2 = u8(data_addr + 1)) && _ref2 === (_ref1 = u8(data_addr + 2))) && _ref1 === u8(data_addr + 3))) {
            decode_u32(data_addr + 4, wrapped_cb);
          }
      }
    }
  };

  exports.is_zcode = function(bytes) {
    var _ref;
    return bytes.length >= 0x40 && bytes[0] >= 3 && (bytes[0x10] & 0xfe) === 0 && ((bytes[0x12] & 0xf0) === (_ref = bytes[0x13] & 0xf0) && _ref === 0x30);
  };

  exports.extract_zcode_strings = function(bytes, cb) {
    var a, abbrev_byte_addr, s, str_w, u16_b, u16_w, unicode_table, version, _i, _ref;
    if (!exports.is_zcode(bytes)) {
      throw new Error('not z-code v3+');
    }
    u16_b = function(byte_addr) {
      return bytes[byte_addr] << 8 | bytes[byte_addr + 1];
    };
    u16_w = function(word_addr) {
      return u16_b(2 * word_addr);
    };
    version = bytes[0];
    abbrev_byte_addr = u16_b(0x18);
    unicode_table = [];
    str_w = function(word_addr, no_abbrev) {
      var a, a0, a1, a2, abbrev, piece, pieces, shift, tenbit, v, z, zscii, _i, _len, _ref;
      a0 = 'abcdefghijklmnopqrstuvwxyz';
      a1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      a2 = '\x00\n0123456789.,!?_#\'"/\-:()';
      a = a0;
      abbrev = tenbit = null;
      pieces = [];
      while (true) {
        if (2 * word_addr + 1 >= bytes.length) {
          return;
        }
        v = u16_w(word_addr);
        word_addr += 1;
        _ref = [10, 5, 0];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          shift = _ref[_i];
          z = (v >> shift) & 0x1f;
          if (abbrev) {
            a = u16_b(abbrev_byte_addr + 2 * (32 * (abbrev - 1) + z));
            piece = str_w(a, true);
            abbrev = null;
            if (!piece) {
              return;
            }
            pieces.push(piece);
          } else if (tenbit) {
            tenbit.push(z);
            if (tenbit.length < 2) {
              continue;
            }
            zscii = tenbit[0] << 5 | tenbit[1];
            tenbit = null;
            if (zscii >= 252) {
              return;
            } else if ((155 <= zscii && zscii < 155 + unicode_table.length)) {
              pieces.push(unicode_table[zscii - 155]);
            } else {
              pieces.push((function() {
                switch (zscii) {
                  case 11:
                    return '  ';
                  case 13:
                    return '\n';
                  default:
                    return String.fromCharCode(zscii);
                }
              })());
            }
          } else if (z === 0) {
            pieces.push(' ');
          } else if (__indexOf.call([1, 2, 3], z) >= 0) {
            if (no_abbrev) {
              return;
            }
            abbrev = z;
          } else if (z === 4) {
            a = a1;
          } else if (z === 5) {
            a = a2;
          } else {
            piece = a[z - 6];
            a = a0;
            if (piece === '\x00') {
              tenbit = [];
            } else {
              pieces.push(piece);
            }
          }
        }
        if (v >> 15) {
          return pieces.join('');
        }
      }
    };
    for (a = _i = 0x20, _ref = Math.floor(bytes.length / 2); 0x20 <= _ref ? _i <= _ref : _i >= _ref; a = 0x20 <= _ref ? ++_i : --_i) {
      if (u16_w(a - 1) >> 15 && (s = str_w(a))) {
        cb(s, 2 * a);
      }
    }
  };

  exports.extract_strings = function(bytes, cb) {
    if (exports.is_zcode(bytes)) {
      return exports.extract_zcode_strings(bytes, cb);
    } else {
      return exports.extract_glulx_strings(bytes, cb);
    }
  };

  if ((typeof module !== "undefined" && module !== null) && module === (typeof require !== "undefined" && require !== null ? require.main : void 0)) {
    fs = require('fs');
    bytes = fs.readFileSync(process.argv[2]);
    exports.extract_strings(bytes, function(s) {
      s = s.trimRight();
      if (s) {
        return console.log(s);
      }
    });
  }

}).call(this);
